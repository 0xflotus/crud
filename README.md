<!-- [![Build Status](https://travis-ci.org/zMotivat0r/nest-crud.svg?branch=master)](https://travis-ci.org/zMotivat0r/nest-crud)
[![Coverage Status](https://img.shields.io/coveralls/github/zMotivat0r/nest-crud.svg)](https://coveralls.io/github/zMotivat0r/nest-crud?branch=master&&service=github) -->

<p align="center">
  <a href="https://github.com/nestjsx" target="blank"><img src="https://github.com/nestjsx/nestjsx/raw/master/img/logo.png" width="160" alt="Nestjsx Logo" /></a>
</p>
<p align="center">
  A set of opinionated <a href="https://github.com/nestjs/nest" target="blank">NestJS</a> extensions and modules
</p>
<p align="center">
  <a href="https://github.com/nestjsx/crud/blob/master/LICENSE"><img src="https://img.shields.io/github/license/nestjsx/crud.svg" alt="License" /></a>
</p>

# NestJs CRUD for RESTful APIs

`@nestjsx/crud` has been designed for creating CRUD controllers and services for RESTful applications built with NestJs. It can be used with TypeORM repositories for now, but Mongoose functionality available in the future.

## Table of Contents

- [Install](#install)
- [Getting started](#getting-started)
  - [Entity](#entity)
  - [Repository service](#repository-service)
  - [CRUD controller](#crud-controller)
  - [API endpoints](#api-endpoints)
- [RESTful query parameters](#restful-query-parameters)
  - [fields](#fields)
  - [filter](#filter)
    - [filter conditions](#filter-conditions)
  - [or](#or)

---

## Install

```bash
npm i @nestjsx/crud typeorm @nestjs/typeorm --save
```

## Getting started

### Entity

Assume you have some typorm enitity:

```typescript
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class Hero {
  @PrimaryGeneratedColumn() id: number;

  @Column() name: string;
}
```

### Repository Service

Next, let's create a service for it:

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { RepositoryService } from '@nestjsx/crud/typeorm';

import { Hero } from './hero.entity';

@Injectable()
export class HeroesService extends RepositoryService<Hero> {
  constructor(@InjectRepository(Hero) repo) {
    super(repo);
  }
}
```

Just like that!

### CRUD Controller

Next, let create a CRUD controller that expose some RESTful endpoints for us:

```typescript
import { Controller } from '@nestjs/common';
import { Crud, CrudController } from '@nestjsx/crud';

import { Hero } from './hero.entity';
import { HeroesService } from './heroes.service';

@Crud(Hero)
@Controller('heroes')
export class HeroesController implements CrudController<HeroesService, Hero> {
  constructor(service: HeroesService) {
    super(service);
  }
}
```

And that's it, no more inheritance and tight coupling. Let's see what happens here:

```typescript
@Crud(Hero)
```

We pass our `Hero` entity as a `dto` for validation purpose (you can pass any other Dto class that fits you needs). So, if you use [class-validator](https://github.com/typestack/class-validator) and [class-transformer](https://github.com/typestack/class-transformer) packages and [ValidationPipe](https://docs.nestjs.com/techniques/validation) (or maybe your own implementation of it), in that case you can use validation decorators inside your entity class. Pretty handy, right?  
If you don't use those, the implementation of request data validation is your own prerogative.

```typescript
implements CrudController<HeroesService, Hero>
```

If you are not planning to override generated endpoints and you're pretty much sure that your service extends `RepositoryService`, in that case you can remove interface here.

After that, all you have to do is to hook up everything in your module. By doing this simple steps your application will expose these endpoints:

### API endpoints

- `GET /heroes` - get list of heroes
- `GET /heroes/:id` - get one hero by id
- `POST /heroes` - create new hero
- `POST /heroes/bulk` - create many heroes
- `PATCH /heroes/:id` - update existing hero
- `DELETE /heroes/:id` - delete one hero

## RESTful query parameters

`GET` endpoints that are generated by CRUD controller support some useful query parameters (all of them are _optional_):

- **`fields`** - get selected fields in GET result
- **`filter`** (alias: `filter[]`) - filter GET result by `AND` type of condition
- **`or`** (alias: `or[]`) - filter GET result by `OR` type of condition
- **`sort`** (alias: `sort[]`) - sort GET result by some `field` in `ASC | DESC` order
- **`join`** (alias: `join[]`) - receive joined relational entities in GET result (with all or selected fields)
- **`limit`** (alias `per_page`) - receive `N` amount of entities
- **`offset`** (alias `skip`) - offset `N` amount of entities
- **`page`** - receive a portion of `limit` (`per_page`) entities (alternative to `offset`)
- **`cache`** - reset cache (if was enabled) and receive entities from the DB

### fields

Selects fields that should be returned in the reponse body.

_Syntax:_

> ?fields=**field1**,**field2**,...

_Example:_

> ?fields=**email**,**name**

### filter

Adds fields request condition (multiple conditions) to you request.

_Syntax:_

> ?filter=**field**||**condition**||**value**

_Examples:_

> ?filter=**name**||**eq**||**batman**

> ?filter=**isVillain**||**eq**||**false**&filter=**city**||**eq**||**Arkham** (multiple filters are treated as a combination of `AND` type of conditions)

> ?filter=**shots**||**in**||**12**,**26** (some conditions accept multiple values separated by commas)

> ?filter=**power**||**isnull** (some conditions don't accept value)

_Alias:_ `filter[]`

### filter conditions

(**condition** - `operator`):

- **`eq`** (`=`, equal)
- **`ne`** (`!=`, not equal)
- **`gt`** (`>`, greater than)
- **`lt`** (`<`, lower that)
- **`gte`** (`>=`, greater than or equal)
- **`lte`** (`<=`, lower than or equal)
- **`starts`** (`LIKE val%`, starts with)
- **`ends`** (`LIKE %val`, ends with)
- **`cont`** (`LIKE %val%`, contains)
- **`excl`** (`NOT LIKE %val%`, not contains)
- **`in`** (`IN`, in range, **_accepts multiple values_**)
- **`notin`** (`NOT IN`, not in range, **_accepts multiple values_**)
- **`isnull`** (`IS NULL`, is NULL, **_doesn't accept value_**)
- **`notnull`** (`IS NOT NULL`, not NULL, **_doesn't accept value_**)
- **`between`** (`BETWEEN`, between, **_accepts two values_**)

### or

Adds `OR` conditions to the request

_Syntax:_

> ?or=**field**||**condition**||**value**
