<!-- [![Build Status](https://travis-ci.org/zMotivat0r/nest-crud.svg?branch=master)](https://travis-ci.org/zMotivat0r/nest-crud)
[![Coverage Status](https://img.shields.io/coveralls/github/zMotivat0r/nest-crud.svg)](https://coveralls.io/github/zMotivat0r/nest-crud?branch=master&&service=github) -->

<p align="center">
  <a href="https://github.com/nestjsx" target="blank"><img src="https://github.com/nestjsx/nestjsx/raw/master/img/logo.png" width="160" alt="Nestjsx Logo" /></a>
</p>
<p align="center">
  A set of opinionated <a href="https://github.com/nestjs/nest" target="blank">NestJS</a> extensions and modules
</p>
<p align="center">
  <a href="https://github.com/nestjsx/crud/blob/master/LICENSE"><img src="https://img.shields.io/github/license/nestjsx/crud.svg" alt="License" /></a>
</p>

# NestJs CRUD for RESTful APIs

`@nestjsx/crud` has been designed for creating CRUD controllers and services for RESTful applications built with NestJs. It can be used with TypeORM repositories for now, but Mongoose functionality available in the future.

## Features and merits

- CRUD endpoints generation, based on a repository service and an entity.
- Ability to generate CRUD endpoints with predefined path parameters.
- Composition of controller methods instead of inheritance (no tight coupling and less surprises)
- Overriding controller methods with ease.
- Request validation.
- Query parameters parsing with filters, pagination, sorting, etc.
- Super fast DB query building.
- Additional handy decorators.

## Table of Contents

- [Install](#install)
- [Getting started](#getting-started)
  - [Entity](#entity)
  - [Service](#service)
  - [Controller](#controller)
  - [API endpoints](#api-endpoints)
- [Query parameters](#query-parameters)
- [RepositoryService](#repositoryservice)
  - [RestfulOptions](#restfuloptions)
- [CrudController](#crudcontroller)
  - [IntelliSense](#intellisense)
  - [RestfulOptions merge](#restfuloptions-merge)
  - [Predefined path](#predefined-path)
  - [Additional Decorators](#additional-decorators)

---

## Install

```bash
npm i @nestjsx/crud typeorm @nestjs/typeorm --save
```

## Getting started

### Entity

Assume you have some TypeORM enitity:

```typescript
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class Hero {
  @PrimaryGeneratedColumn() id: number;

  @Column() name: string;
}
```

### Service

Next, let's create a [RepositoryService](#repositoryservice) for it:

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { RepositoryService } from '@nestjsx/crud/typeorm';

import { Hero } from './hero.entity';

@Injectable()
export class HeroesService extends RepositoryService<Hero> {
  constructor(@InjectRepository(Hero) repo) {
    super(repo);
  }
}
```

Just like that!

### Controller

Next, let create a [CrudController](#crudcontroller) that expose some RESTful endpoints for us:

```typescript
import { Controller } from '@nestjs/common';
import { Crud } from '@nestjsx/crud';

import { Hero } from './hero.entity';
import { HeroesService } from './heroes.service';

@Crud(Hero)
@Controller('heroes')
export class HeroesController {
  constructor(service: HeroesService) {}
}
```

And that's it, no more inheritance and tight coupling. Let's see what happens here:

```typescript
@Crud(Hero)
```

We pass our `Hero` entity as a `dto` for validation purpose (you can pass any other Dto class that fits you needs). So, if you use [class-validator](https://github.com/typestack/class-validator) and [class-transformer](https://github.com/typestack/class-transformer) packages and [ValidationPipe](https://docs.nestjs.com/techniques/validation) (or maybe your own implementation of it), in that case you can use validation decorators inside your entity class. Pretty handy, right?  
If you don't use those, the implementation of request data validation is your own prerogative.

After that, all you have to do is to hook up everything in your module. And after being done with these simple steps your application will expose these endpoints:

### API endpoints

- `GET /heroes` - get list of heroes
- `GET /heroes/:id` - get one hero by id
- `POST /heroes` - create new hero
- `POST /heroes/bulk` - create many heroes
- `PATCH /heroes/:id` - update existing hero
- `DELETE /heroes/:id` - delete one hero

## Query parameters

`GET` endpoints that are generated by CRUD controller support some useful query parameters (all of them are _optional_):

- [**`fields`**](#fields) - get selected fields in GET result
- [**`filter`**](#filter) (alias: `filter[]`) - filter GET result by `AND` type of condition
- [**`or`**](#or) (alias: `or[]`) - filter GET result by `OR` type of condition
- [**`sort`**](#sort) (alias: `sort[]`) - sort GET result by some `field` in `ASC | DESC` order
- [**`join`**](join) (alias: `join[]`) - receive joined relational entities in GET result (with all or selected fields)
- [**`limit`**](#limit) (alias `per_page`) - receive `N` amount of entities
- [**`offset`**](#offset) (alias `skip`) - offset `N` amount of entities
- [**`page`**](#page) - receive a portion of `limit` (`per_page`) entities (alternative to `offset`)
- [**`cache`**](#cache) - reset cache (if was enabled) and receive entities from the DB

### fields

Selects fields that should be returned in the reponse body.

_Syntax:_

> ?fields=**field1**,**field2**,...

_Example:_

> ?fields=**email**,**name**

### filter

Adds fields request condition (multiple conditions) to you request.

_Syntax:_

> ?filter=**field**||**condition**||**value**

_Examples:_

> ?filter=**name**||**eq**||**batman**

> ?filter=**isVillain**||**eq**||**false**&filter=**city**||**eq**||**Arkham** (multiple filters are treated as a combination of `AND` type of conditions)

> ?filter=**shots**||**in**||**12**,**26** (some conditions accept multiple values separated by commas)

> ?filter=**power**||**isnull** (some conditions don't accept value)

_Alias:_ `filter[]`

### filter conditions

(**condition** - `operator`):

- **`eq`** (`=`, equal)
- **`ne`** (`!=`, not equal)
- **`gt`** (`>`, greater than)
- **`lt`** (`<`, lower that)
- **`gte`** (`>=`, greater than or equal)
- **`lte`** (`<=`, lower than or equal)
- **`starts`** (`LIKE val%`, starts with)
- **`ends`** (`LIKE %val`, ends with)
- **`cont`** (`LIKE %val%`, contains)
- **`excl`** (`NOT LIKE %val%`, not contains)
- **`in`** (`IN`, in range, **_accepts multiple values_**)
- **`notin`** (`NOT IN`, not in range, **_accepts multiple values_**)
- **`isnull`** (`IS NULL`, is NULL, **_doesn't accept value_**)
- **`notnull`** (`IS NOT NULL`, not NULL, **_doesn't accept value_**)
- **`between`** (`BETWEEN`, between, **_accepts two values_**)

### or

Adds `OR` conditions to the request.

_Syntax:_

> ?or=**field**||**condition**||**value**

It uses the same [filter conditions](#filter-conditions).

_Rules and examples:_

- If there is only **one** `or` present (without `filter`) then it will be interpreted as simple [filter](#filter):

> ?or=**name**||**eq**||**batman**

- If there are **multiple** `or` present (without `filter`) then it will be interpreted as a compination of `OR` conditions, as follows:  
  `WHERE {or} OR {or} OR ...`

> ?or=**name**||**eq**||**batman**&or=**name**||**eq**||**joker**

- If there are **one** `or` and **one** `filter` then it will be interpreted as `OR` condition, as follows:  
  `WHERE {filter} OR {or}`

> ?filter=**name**||**eq**||**batman**&or=**name**||**eq**||**joker**

- If present **both** `or` and `filter` in any amount (**one** or **miltiple** each) then both interpreted as a combitation of `AND` conditions and compared with each other by `OR` condition, as follows:  
  `WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)`

> ?filter=**type**||**eq**||**hero**&filter=**status**||**eq**||**alive**&or=**type**||**eq**||**villain**&or=**status**||**eq**||**dead**

_Alias:_ `or[]`

### sort

Adds sort by field (by multiple fields) and order to query result.

_Syntax:_

> ?sort=**field**,**ASC|DESC**

_Examples:_

> ?sort=**name**,**ASC**

> ?sort=**name**,**ASC**&sort=**id**,**DESC**

_Alias:_ `sort[]`

### join

Receive joined relational objects in GET result (with all or selected fields). You can join as many relations as allowed in your [RestfulOptions](#restfuloptions).

_Syntax:_

> ?join=**relation**

> ?join=**relation**||**field1**,**field2**,...

_Examples:_

> ?join=**profile**

> ?join=**profile**||**firstName**,**email**

> ?join=**profile**||**firstName**,**email**&join=**notifications**||**content**&join=**tasks**

**_Notice:_** `id` field always persists in relational objects.

_Alias:_ `join[]`

### limit

Receive `N` amount of entities.

_Syntax:_

> ?limit=**number**

_Example:_

> ?limit=**10**

_Alias:_ `per_page`

### offset

Offset `N` amount of entities

_Syntax:_

> ?offset=**number**

_Example:_

> ?offset=**10**

### page

Receive a portion of `limit` (`per_page`) entities (alternative to `offset`). Will be applied if `limit` is set up.

_Syntax:_

> ?page=**number**

_Example:_

> ?page=**2**

### cache

Reset cache (if was enabled) and receive entities from the DB.

_Usage:_

> ?cache=0

## RepositoryService

`RepositoryService` is the main class where all DB operations related logic is in place.

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { RepositoryService } from '@nestjsx/crud/typeorm';
import { RestfulOptions } from '@nestjsx/crud';

import { Hero } from './hero.entity';

@Injectable()
export class HeroesService extends RepositoryService<Hero> {
  protected options: RestfulOptions = {};

  constructor(@InjectRepository(Hero) repo) {
    super(repo);
  }
}
```

This class can accept optional parameter called `options` that will be used as default options for `GET` requests. All fields inside that parameter are otional as well.

### RestfulOptions

- [**`allow`**](#allow-option)
- [**`exclude`**](#exclude-option)
- [**`persist`**](#persist-option)
- [**`filter`**](#filter-option)
- [**`join`**](#join-option)
- [**`sort`**](#sort-option)
- [**`limit`**](#limit-option)
- [**`maxLimit`**](#maxlimit-option)
- [**`cache`**](#cache-option)

### allow option

An Array of [fields](#fields) that are allowed to receive in `GET` request. If empty or _undefined_ - allow all.

```typescript
{
  allow: ['name', 'email'];
}
```

### exclude option

an Array of [fields](#fields) that will be excluded from the `GET` response (and not queried from the DB).

```typescript
{
  exclude: ['accessToken'];
}
```

### persist option

An Array of [fields](#fields) that will be always persisted in `GET` response

```typescript
{
  persist: ['createdAt'];
}
```

**_Notice:_** `id` field always persists automatically.

### filter option

An Array of `filter` objects that will be merged (combined) with query [filter](#filter) if those are passed in `GET` request. If not - `filter` will be added to the DB query as a stand-alone condition.

If fultiple items are added, they will be interpreted as `AND` type of conditions.

```typescript
{
  filter: [
    {
      field: 'deleted',
      operator: 'ne',
      value: true,
    },
  ];
}
```

`operator` property is the same as [filter conditions](#filter-conditions).

### join option

An Object of [relations](http://typeorm.io/#/relations) that allowed to be fetched by passing [join](#join) query parameter in `GET` requests.

```typescript
{
  join: {
    profile: {
      persist: ['name']
    },
    tasks: {
      allow: ['content'],
    },
    notifications: {
      exclude: ['token']
    },
    company: {}
  }
}
```

Each key of `join` object must **strongly match** the name of the corresponding entity relation. If particular relation name **is not** present in this option, then user **will not be able** to [join](#join) it in `GET` request.

Each relation option can have [allow](#allow-option), [exclude](#exclude-option) and [persist](#persist-option). All of them are optional as well.

### sort option

An Array of `sort` objects that will be merged (combined) with query [sort](#sort) if those are passed in `GET` request. If not - `sort` will be added to the DB query as a stand-alone condition.

```typescript
{
  sort: [
    {
      field: 'id',
      order: 'DESC',
    },
  ];
}
```

### limit option

Default [limit](#limit) that will be aplied to the DB query.

```typescript
{
  limit: 25,
}
```

### maxLimit option

Max amount of results that can be queried in `GET` request.

```typescript
{
  maxLimit: 100,
}
```

**_Notice:_** **_it's strongly recommended to set up this option. Otherwise DB query will be executed without any LIMIT if no [limit](#limit) was passed in the query or if the [limit option](#limit-option) hasn't been set up_**.

### cache option

If [Caching Results](http://typeorm.io/#/caching) is implemented on you project, then you can set up default `cache` in milliseconds for `GET` response data.

```typescript
{
  cache: 2000,
}
```

`Cache.id` strategy is based on a query that is built by a service, so if you change one of the query parameters in the next request, the result will be returned by DB and saved in the cache.

Cache can be [reseted](#cache) by using the query parameter in your `GET` requests.

## CrudController

Our newly generated working horse. Let's dive in some details.

### IntelliSense

Please, keep in mind that we compose `HeroesController.prototype` by the logic inside our `@Crud()` class decorator. And there are some unpleasant but not very significant side effects of this approach.

First, there is no IntelliSense on composed methods. That's why we need to use `CrudController` interfase:

```typescript
...
import { Crud, CrudController } from '@nestjsx/crud';

@Crud(Hero)
@Controller('heroes')
export class HeroesController implements CrudController<HeroesService, Hero> {
  constructor(service: HeroesService) {}
}
```

This will help to make sure that you're injecting proper [RepositoryService](#repositoryservice).

Second, even after adding `CrudController` interface you still wouldn't see composed methods, accessible from `this` keyword, furthermore, you'll get a TS error. In order to solve this, I've couldn't came up with better idea than this:

```typescript
...
import { Crud, CrudController } from '@nestjsx/crud';

@Crud(Hero)
@Controller('heroes')
export class HeroesController implements CrudController<HeroesService, Hero> {
  constructor(service: HeroesService) {}

  get base(): CrudController<HeroesService, Hero> {
    return this;
  }
}
```

### RestfulOptions merge

```typescript
...
import { Crud, CrudController, RestfulOptions } from '@nestjsx/crud';

@Crud(Hero)
@Controller('heroes')
export class HeroesController implements CrudController<HeroesService, Hero> {
  options: RestfulOptions = {};

  constructor(service: HeroesService) {}
}
```

Controller can accept optioanl `options` parameter and it's the same object as [RestfulOptions](#restfuloptions). It's very useful when you have one `RepositoryService` and several controllers.

**_Notice:_** If you have this options set up in your `RepositoryService`, in that case they will be **merged**.

### Predefined path

Assume, you have an entity `User` that belongs to some `Company` and has a field `companyId`. And you whant to create `UsersController` so that an admin could access users from his own Company only. Let's do this:

```typescript
...
import { Crud, CrudController, RestfulOptions } from '@nestjsx/crud';

@Crud(Hero)
@Controller('/company/:companyId/users')
export class UsersController implements CrudController<UsersService, User> {
  paramsFilter = ['companyId'];

  constructor(service: UsersService) {}
}
```

A property `paramsFilter` is designed fo that purpose.

In this example you're URL param name `companyId` should matche the name of `User.companyId` field. If not, you can do mapping, like this:

```typescript
...
import { Crud, CrudController, RestfulOptions } from '@nestjsx/crud';

@Crud(Hero)
@Controller('/company/:company/users')
export class UsersController implements CrudController<UsersService, User> {
  paramsFilter = {
    company: 'companyId'
  };

  constructor(service: UsersService) {}
}
```

Where `company` - name of the URL param, and `companyId` - name of the entity field.

As you might guess, all request will add `companyId` to the DB queries alongside with the `:id` of `GET`, `PATCH`, `DELETE` requests. On `POST` (both: one and bulk) requests, `companyId` will be added to the `dto` automatically.

When you done with the controller, you'll need to add some logic to you `AuthGuard` or any other interface, where you do the authorization of a requester. You will need to match `companyId` URL param with the `user.companyId` entity that has been validated from the DB.

### Additional Decorators

There are two additional decorators that come in out of the box: `@Feature()` and `@Action()`:

```typescript
...
import { Feature, Crud, CrudController, RestfulOptions } from '@nestjsx/crud';

@Feature('Heroes')
@Crud(Hero)
@Controller('heroes')
export class HeroesController {
  constructor(service: HeroesService) {}
}
```

You can use them with your [ACL](https://en.wikipedia.org/wiki/Access_control_list) implementation. `@Action()` will be applyed automaticaly on controller prototype composition. There is `CrudActions` enum that you can import:

```typescript
enum CrudActions {
  ReadAll = 'Read-All',
  ReadOne = 'Read-One',
  CreateOne = 'Create-One',
  CreateMany = 'Create-Many',
  UpdateOne = 'Update-One',
  DeleteOne = 'Delete-One',
  DeleteAll = 'Delete-All',
}
```
